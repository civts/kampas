use crate::{
    generate_endpoint_roles,
    helpers::surrealdb::{ranking::add_ranking, tag::get_tag_control_association},
    models::{
        measure::Measure,
        ranking::{RankOrdering, Ranking},
        role::Role,
        user::User,
    },
};
use crate::{
    helpers::{error::Error, surrealdb},
    models::control::Control,
};
use ::surrealdb::{engine::remote::ws::Client, Surreal};
use rocket::{form::Form, http::Status, response::status, State};
use rocket::{
    request::{FromRequest, Outcome, Request},
    serde::json::serde_json,
};
use std::collections::HashSet;
use std::collections::{BTreeMap, HashMap};

#[derive(Debug, FromForm)]
pub(crate) struct CreateRankingParams {
    #[field(validate = range(1..101), default = 100)]
    /// Minimum coverage (in percentage) that a control
    /// must have in order to be considered complete
    minimum_coverage: u8,
    /// List of tags that the controls must have to be included in the ranking.
    /// if this list is not specified, all controls are included.
    filter_tags: Option<Vec<String>>,
    /// Used only if filter_tags is not none.
    /// If true, a control must have all the tags to be included.
    /// If false, a control is included if it has at least one of the tags
    #[field(default = false)]
    all_tags: bool,
    #[field(validate = len(1..101))]
    name: String,
}

generate_endpoint_roles!(CreateRankingRole, { Role::CreateRanking });
#[post("/", data = "<form_data>")]
pub(crate) async fn new_ranking(
    form_data: Form<CreateRankingParams>,
    _r: CreateRankingRole,
    user: User,
    db: &State<Surreal<Client>>,
) -> status::Custom<String> {
    let name = form_data.name.clone();
    let minimum_coverage = form_data.minimum_coverage.clone();
    match generate_ranking(&form_data.into_inner(), db).await {
        Ok((measures, controls)) => {
            // Save ranking to db
            let ranking = Ranking::new(
                measures,
                controls,
                &user.username,
                RankOrdering::GreedyWeightedSetCover,
                &name,
                minimum_coverage,
            );
            match add_ranking(ranking, db).await {
                Ok(ranking_id) => {
                    println!("New ranking generated by {}: {}", user.username, ranking_id);
                    status::Custom(Status::Ok, ranking_id)
                }
                Err(err) => {
                    println!("Something went wrong adding the ranking to the database: {err:?}");
                    status::Custom(
                        Status::InternalServerError,
                        Status::InternalServerError.reason_lossy().into(),
                    )
                }
            }
        }
        Err(err) => {
            println!("Something went wrong creating the ranking: {err:?}");
            status::Custom(
                Status::InternalServerError,
                Status::InternalServerError.reason_lossy().into(),
            )
        }
    }
}

generate_endpoint_roles!(GetRakingsRole, { Role::GetRankings });
#[get("/")]
pub(crate) async fn get_rankings(
    user: User,
    _required_roles: GetRakingsRole,
    db: &State<Surreal<Client>>,
) -> status::Custom<String> {
    let rankings_res = surrealdb::ranking::get_rankings(db).await;
    println!("{} is requesting the rankings", user.username);
    match rankings_res {
        Ok(rankings) => status::Custom(
            Status::Ok,
            serde_json::to_string(&rankings).expect("can serialize the rankings to JSON"),
        ),
        Err(err) => {
            println!("Something went wrong getting the rankings: {}", err);
            status::Custom(
                Status::InternalServerError,
                Status::InternalServerError.reason_lossy().to_string(),
            )
        }
    }
}

#[get("/<ranking_id>")]
pub(crate) async fn get_ranking(
    user: User,
    ranking_id: String,
    _required_roles: GetRakingsRole,
    db: &State<Surreal<Client>>,
) -> status::Custom<String> {
    println!("{} is requesting the ranking {ranking_id}", user.username);
    let rankings_res = surrealdb::ranking::get_ranking(&ranking_id, db).await;
    match rankings_res {
        Ok(ranking) => status::Custom(
            Status::Ok,
            serde_json::to_string(&ranking).expect("can serialize the ranking to JSON"),
        ),
        Err(err) => {
            println!("Something went wrong getting the rankings: {}", err);
            status::Custom(
                Status::InternalServerError,
                Status::InternalServerError.reason_lossy().to_string(),
            )
        }
    }
}

async fn generate_ranking(
    params: &CreateRankingParams,
    db: &State<Surreal<Client>>,
) -> Result<(Vec<String>, Vec<String>), Error> {
    // Get all the controls from the database
    let controls = get_filtered_controls(db, params).await?;
    // Get all the measures from the database
    let measures = surrealdb::measure::get_measures(db).await?;

    // Get the relation between controls and measures
    let mut controls_for_measure = surrealdb::measure::get_measure_control_association(db).await?;
    let control_ids: HashSet<&String> = HashSet::from_iter(controls.iter().map(|c| &c.identifier));
    for (_, v) in controls_for_measure.iter_mut() {
        v.retain(|(cid, _)| control_ids.contains(cid))
    }

    let completion_vec = surrealdb::control::get_control_completion_batch(
        db,
        controls.iter().map(|c| c.identifier.clone()).collect(),
    )
    .await?;

    let mut completion_map = HashMap::new();
    for i in 0..controls.len() {
        let identifier = controls.get(i).expect("there is a control");
        let compl = completion_vec.get(i).expect("there is a completion");
        completion_map.insert(identifier.identifier.clone(), *compl);
    }

    // Start greedy: take the measure with the most associated controls (divided by its effort), strike out the controls
    let (best_measures, controls_satisfied) = minimize_cost(
        &controls,
        &measures,
        &controls_for_measure,
        &completion_map,
        params.minimum_coverage,
    );

    let best_measures = Vec::from_iter(best_measures.into_iter());
    Ok((best_measures, controls_satisfied))
}

async fn get_filtered_controls(
    db: &State<Surreal<Client>>,
    params: &CreateRankingParams,
) -> Result<Vec<Control>, Error> {
    let controls = surrealdb::control::get_controls(db).await?;
    Ok(match &params.filter_tags {
        None => controls,
        Some(tags_to_filter) => {
            if tags_to_filter.is_empty() {
                if params.all_tags {
                    controls
                } else {
                    Vec::new()
                }
            } else {
                let requested_tags: HashSet<&str> =
                    HashSet::from_iter(tags_to_filter.iter().map(|s| s.as_str()));
                let tag_control_associations = get_tag_control_association(db).await?;
                let mut relevant_associations = tag_control_associations
                    .iter()
                    .filter(|(tag_id, _controls)| requested_tags.contains(tag_id.as_str()))
                    .map(|(_tag_id, controls)| {
                        HashSet::from_iter(controls.iter().map(|c| c.as_str()))
                    });
                let relevant_control_ids: HashSet<&str> = if params.all_tags {
                    let firstset = relevant_associations
                        .next()
                        .expect("There is at least one tag association");
                    //Fold the tags intersetcting the controls sets, then filter the controls
                    relevant_associations.fold(firstset, |prev, value| {
                        prev.intersection(&value).map(|c| *c).collect()
                    })
                } else {
                    relevant_associations.fold(HashSet::new(), |prev, value| {
                        prev.union(&value).map(|c| *c).collect()
                    })
                };
                controls
                    .iter()
                    .filter(|control| relevant_control_ids.contains(control.identifier.as_str()))
                    .map(|c| c.to_owned())
                    .collect()
            }
        }
    })
}

/// Finds the best measures to minimize the cost. This is a variant of the Weighted Set
/// Cover problem.
///
/// We solve it with a greedy algorithm, computing the cost for each measure and always
/// choosing the smallest one. To compute the cost, we divide the effort of the measure
/// by the total increase in coverage it would bring. To compute the increase in
/// coverage, we sum the one on each control the measure covers, but only if the control
/// was not completely covered yet.
pub(crate) fn minimize_cost(
    controls: &[Control],
    measures: &[Measure],
    coverage_map: &BTreeMap<String, Vec<(String, u8)>>,
    completion_map: &HashMap<String, f64>,
    min_progress: u8,
) -> (Vec<String>, Vec<String>) {
    println!(
        "About to minimize the cost for {} controls and {} measures",
        controls.len(),
        measures.len()
    );
    let mut selected_measures: Vec<String> = vec![];

    // Measure id with measure, only unselected ones
    let mut remaining_measures: HashMap<&String, &Measure> =
        HashMap::from_iter(measures.iter().map(|m| (&m.identifier, m)));
    // Control id with control, only incomplete ones
    let mut incomplete_controls: HashMap<&String, &Control> =
        HashMap::from_iter(controls.iter().map(|c| (&c.identifier, c)));
    let mut completion_now: HashMap<String, f64> = completion_map.clone();
    let emptyvec = Vec::new();
    while !(remaining_measures.is_empty() || incomplete_controls.is_empty()) {
        //find best measure
        let mut lowest_cost = f64::MAX;
        let mut best_measure = None;
        for measure in remaining_measures.values() {
            if let Some(covered_controls) = coverage_map.get(&measure.identifier) {
                let covers_an_incomplete_control = covered_controls
                    .iter()
                    .any(|control| incomplete_controls.contains_key(&control.0));

                if covers_an_incomplete_control {
                    let cost = measure_cost(measure, covered_controls, &incomplete_controls);
                    if cost < lowest_cost {
                        lowest_cost = cost;
                        best_measure = Some(measure);
                    }
                } else {
                    println!(
                        "Measure {} only covers complete controls",
                        &measure.identifier
                    );
                }
            }
        }
        //add to solution
        if let Some(measure) = best_measure {
            println!("Chose measure {} {}", measure.identifier, measure.title);
            println!(">>>>>>>> cost: {lowest_cost}");
            let controls = coverage_map.get(&measure.identifier).unwrap_or(&emptyvec);
            for (control, coverage) in controls {
                if let Some(prev) = completion_now.get(control) {
                    let coverage_increase =
                        ((100 - measure.progress) as f64) / 100f64 * (*coverage as f64);
                    let updated = prev + coverage_increase;
                    completion_now.insert(control.to_string(), updated);
                    if updated >= (min_progress as f64) {
                        println!("Marking control {control} as complete");
                        incomplete_controls.remove(control);
                    }
                }
            }
            selected_measures.push(measure.identifier.clone());
            remaining_measures.remove(&measure.identifier);
        } else {
            println!("Did not find any best measure");
            break;
        }
    }
    println!(
        "Ended because no more measures {}, no more controls {}",
        remaining_measures.is_empty(),
        incomplete_controls.is_empty()
    );
    let covered_controls = Vec::from_iter(controls.iter().map(|c| c.identifier.to_owned()).filter(
        |id| {
            completion_now
                .get(id)
                .map(|v| v >= &(min_progress as f64))
                .unwrap_or(false)
        },
    ));
    println!(
        "{}/{} controls covered with {}/{} measures",
        covered_controls.len(),
        controls.len(),
        selected_measures.len(),
        measures.len()
    );
    (selected_measures, covered_controls)
}

fn measure_cost(
    measure: &Measure,
    covered_controls: &Vec<(String, u8)>,
    incomplete_controls: &HashMap<&String, &Control>,
) -> f64 {
    if measure.progress == 100 {
        0f64
    } else {
        let coverage_increase = covered_controls
            .iter()
            .filter(|(c, _)| incomplete_controls.contains_key(c))
            .fold(0u64, |prev, (_, cov)| prev + *cov as u64);
        if coverage_increase == 0 {
            f64::MAX
        } else {
            (measure.effort as f64) / (coverage_increase as f64)
        }
    }
}
