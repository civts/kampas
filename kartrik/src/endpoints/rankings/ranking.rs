use crate::{
    generate_endpoint_roles,
    helpers::surrealdb::{ranking::add_ranking, tag::get_tag_control_association},
    models::{
        metric::Metric,
        ranking::{RankOrdering, Ranking},
        role::Role,
        user::User,
    },
};
use crate::{
    helpers::{error::Error, surrealdb},
    models::control::Control,
};
use ::surrealdb::{engine::remote::ws::Client, Surreal};
use rocket::{form::Form, http::Status, response::status, State};
use rocket::{
    request::{FromRequest, Outcome, Request},
    serde::json::serde_json,
};
use std::collections::HashSet;
use std::collections::{BTreeMap, HashMap};

#[derive(Debug, FromForm)]
pub(crate) struct CreateRankingParams {
    #[field(validate = range(1..101), default = 100)]
    /// Minimum coverage (in percentage) that a control
    /// must have in order to be considered complete
    minimum_coverage: u8,
    /// List of tags that the controls must have to be included in the ranking.
    /// if this list is not specified, all controls are included.
    filter_tags: Option<Vec<String>>,
    /// Used only if filter_tags is not none.
    /// If true, a control must have all the tags to be included.
    /// If false, a control is included if it has at least one of the tags
    #[field(default = false)]
    all_tags: bool,
    #[field(validate = len(1..101))]
    name: String,
}

generate_endpoint_roles!(CreateRankingRole, { Role::CreateRanking });
#[post("/", data = "<form_data>")]
pub(crate) async fn new_ranking(
    form_data: Form<CreateRankingParams>,
    _r: CreateRankingRole,
    user: User,
    db: &State<Surreal<Client>>,
) -> status::Custom<String> {
    let name = form_data.name.clone();
    let minimum_coverage = form_data.minimum_coverage.clone();
    match generate_ranking(&form_data.into_inner(), db).await {
        Ok((metrics, controls)) => {
            // Save ranking to db
            let ranking = Ranking::new(
                metrics,
                controls,
                &user.username,
                RankOrdering::GreedyWeightedSetCover,
                &name,
                minimum_coverage,
            );
            match add_ranking(ranking, db).await {
                Ok(ranking_id) => {
                    println!("New ranking generated by {}: {}", user.username, ranking_id);
                    status::Custom(Status::Ok, ranking_id)
                }
                Err(err) => {
                    println!("Something went wrong adding the ranking to the database: {err:?}");
                    status::Custom(
                        Status::InternalServerError,
                        Status::InternalServerError.reason_lossy().into(),
                    )
                }
            }
        }
        Err(err) => {
            println!("Something went wrong creating the ranking: {err:?}");
            status::Custom(
                Status::InternalServerError,
                Status::InternalServerError.reason_lossy().into(),
            )
        }
    }
}

generate_endpoint_roles!(GetRakingsRole, { Role::GetRankings });
#[get("/")]
pub(crate) async fn get_rankings(
    user: User,
    _required_roles: GetRakingsRole,
    db: &State<Surreal<Client>>,
) -> status::Custom<String> {
    let rankings_res = surrealdb::ranking::get_rankings(db).await;
    println!("{} is requesting the rankings", user.username);
    match rankings_res {
        Ok(rankings) => status::Custom(
            Status::Ok,
            serde_json::to_string(&rankings).expect("can serialize the rankings to JSON"),
        ),
        Err(err) => {
            println!("Something went wrong getting the rankings: {}", err);
            status::Custom(
                Status::InternalServerError,
                "Internal Server Error".to_string(),
            )
        }
    }
}

#[get("/<ranking_id>")]
pub(crate) async fn get_ranking(
    user: User,
    ranking_id: String,
    _required_roles: GetRakingsRole,
    db: &State<Surreal<Client>>,
) -> status::Custom<String> {
    println!("{} is requesting the ranking {ranking_id}", user.username);
    let rankings_res = surrealdb::ranking::get_ranking(&ranking_id, db).await;
    match rankings_res {
        Ok(ranking) => status::Custom(
            Status::Ok,
            serde_json::to_string(&ranking).expect("can serialize the ranking to JSON"),
        ),
        Err(err) => {
            println!("Something went wrong getting the rankings: {}", err);
            status::Custom(
                Status::InternalServerError,
                "Internal Server Error".to_string(),
            )
        }
    }
}

async fn generate_ranking(
    params: &CreateRankingParams,
    db: &State<Surreal<Client>>,
) -> Result<(Vec<String>, Vec<String>), Error> {
    // Get all the controls from the database
    let controls = get_filtered_controls(db, params).await?;
    // Get all the metrics from the database
    let metrics = surrealdb::metric::get_metrics(db).await?;

    // Get the relation between controls and metrics
    let metrics_for_control = surrealdb::metric::get_metric_control_association(db).await?;

    // Start greedy: take the metric with the most associated controls (divided by its effort), strike out the controls
    let (best_metrics, controls_satisfied) = minimize_cost(
        &controls,
        &metrics,
        &metrics_for_control,
        params.minimum_coverage,
    );

    let best_metrics = Vec::from_iter(best_metrics.into_iter());
    Ok((best_metrics, controls_satisfied))
}

async fn get_filtered_controls(
    db: &State<Surreal<Client>>,
    params: &CreateRankingParams,
) -> Result<Vec<Control>, Error> {
    let controls = surrealdb::control::get_controls(db).await?;
    Ok(match &params.filter_tags {
        None => controls,
        Some(tags_to_filter) => {
            if tags_to_filter.is_empty() {
                if params.all_tags {
                    controls
                } else {
                    Vec::new()
                }
            } else {
                let requested_tags: HashSet<&str> =
                    HashSet::from_iter(tags_to_filter.iter().map(|s| s.as_str()));
                let tag_control_associations = get_tag_control_association(db).await?;
                let mut relevant_associations = tag_control_associations
                    .iter()
                    .filter(|(tag_id, _controls)| requested_tags.contains(tag_id.as_str()))
                    .map(|(_tag_id, controls)| {
                        HashSet::from_iter(controls.iter().map(|c| c.as_str()))
                    });
                let relevant_control_ids: HashSet<&str> = if params.all_tags {
                    let firstset = relevant_associations
                        .next()
                        .expect("There is at least one tag association");
                    //Fold the tags intersetcting the controls sets, then filter the controls
                    relevant_associations.fold(firstset, |prev, value| {
                        prev.intersection(&value).map(|c| *c).collect()
                    })
                } else {
                    relevant_associations.fold(HashSet::new(), |prev, value| {
                        prev.union(&value).map(|c| *c).collect()
                    })
                };
                controls
                    .iter()
                    .filter(|control| relevant_control_ids.contains(control.identifier.as_str()))
                    .map(|c| c.to_owned())
                    .collect()
            }
        }
    })
}

/// Finds the best metrics to minimize the cost. This is a variant of the Weighted Set
/// Cover problem.
///
/// We solve it with a greedy algorithm, computing the cost for each metric and always
/// choosing the smallest one. To compute the cost, we divide the effort of the metric
/// by the total increase in coverage it would bring. To compute the increase in
/// coverage, we sum the one on each control the metric covers, but only if the control
/// was not completely covered yet.
pub(crate) fn minimize_cost(
    controls: &[Control],
    metrics: &[Metric],
    coverage_map: &BTreeMap<String, Vec<(String, u8)>>,
    min_coverage: u8,
) -> (Vec<String>, Vec<String>) {
    let mut selected_metrics: Vec<String> = vec![];
    let mut unused_metrics: HashSet<&str> = metrics.iter().map(|m| m.identifier.as_str()).collect();
    let empty_vec = Vec::new();

    let mut remaining_controls: HashSet<&str> =
        controls.iter().map(|c| c.identifier.as_str()).collect();

    let mut controls_coverage: HashMap<&str, u8> = controls
        .iter()
        .map(|c| (c.identifier.as_str(), 0))
        .collect();

    let metric_efforts = BTreeMap::from_iter(
        metrics
            .iter()
            .map(|metric| (metric.identifier.as_str(), metric.effort)),
    );

    // Iterate until all controls are covered, adding the best metric every time
    while !(remaining_controls.is_empty() || unused_metrics.is_empty()) {
        let mut min_cost = f64::MAX;
        let mut best_metric: Option<&str> = None;

        for metric_id in &unused_metrics {
            // Controls that would be covered by this metric
            let covered_controls = coverage_map.get(*metric_id).unwrap_or(&empty_vec);

            let effort = *metric_efforts
                .get(metric_id)
                .expect("can get effort for metric") as f64;
            let coverage_increase = covered_controls.iter().fold(0, |prev, c| {
                let control_id = c.0.as_str();
                let coverage = c.1;
                if
                // remaining_controls.contains(control_id) &&
                controls_coverage
                    .get(control_id)
                    .map(|coverage| coverage < &min_coverage)
                    .unwrap_or(false)
                {
                    // Add the contribution of this metric for this control
                    prev + coverage
                } else {
                    prev
                }
            }) as f64;
            let cost = effort / coverage_increase;

            let covered_ids: HashSet<&str> = covered_controls
                .iter()
                .map(|(control_id, _)| control_id.as_str())
                .collect();
            let incomplete_covered = remaining_controls.intersection(&covered_ids).count();

            // If this metric has the minimum cost and helps covering some incomplete controls
            if incomplete_covered > 0 && cost < min_cost {
                min_cost = cost;
                best_metric = Some(metric_id);
            }
        }

        // Add the best metric to the selected set and remove the covered controls from consideration
        if let Some(metric_id) = best_metric {
            selected_metrics.push(metric_id.to_string());
            unused_metrics.remove(metric_id);

            let controls = &coverage_map.get(metric_id).unwrap_or(&empty_vec);
            controls.iter().for_each(|(control_id, coverage)| {
                let prev_value = controls_coverage.get(control_id.as_str()).unwrap();
                let new_value = prev_value + coverage;
                controls_coverage.insert(control_id, new_value);
            });
            remaining_controls = remaining_controls
                .difference(
                    &controls
                        .iter()
                        .filter(|(control_id, _)| {
                            controls_coverage.get(control_id.as_str()).unwrap() >= &min_coverage
                        })
                        .map(|(c, _)| c.as_str())
                        .collect(),
                )
                .cloned()
                .collect();
        } else {
            break;
        }
    }

    let covered_controls = controls_coverage
        .iter()
        .map(|(id, coverage)| {
            if coverage >= &min_coverage {
                return Some(id.clone().to_owned());
            } else {
                return None;
            }
        })
        .flatten()
        .collect();
    (selected_metrics, covered_controls)
}
