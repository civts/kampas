use crate::{
    generate_endpoint_roles,
    helpers::surrealdb::add_ranking,
    models::{
        metric::Metric,
        ranking::{RankOrdering, Ranking},
        role::Role,
        user::User,
    },
};
use crate::{
    helpers::{error::Error, surrealdb},
    models::control::Control,
};
use ::surrealdb::{engine::remote::ws::Client, Surreal};
use rocket::{form::Form, http::Status, response::status, State};
use rocket::{
    request::{FromRequest, Outcome, Request},
    serde::json::serde_json,
};
use std::collections::HashSet;
use std::collections::{BTreeMap, HashMap};

#[derive(Debug, FromForm)]
pub(crate) struct CreateRankingFormData {
    #[field(validate = range(1..101), default = 100)]
    /// Minimum coverage (in percentage) that a control
    /// must have in order to be considered complete
    minimum_coverage: u8,
}

generate_endpoint_roles!(CreateRankingRole, { Role::CreateRanking });
#[post("/", data = "<form_data>")]
pub(crate) async fn new_ranking(
    form_data: Form<CreateRankingFormData>,
    //_r: CreateRankingRole,
    user: User,
    db: &State<Surreal<Client>>,
) -> status::Custom<String> {
    let min_coverage = form_data.minimum_coverage;
    match generate_ranking(min_coverage, db).await {
        Ok(metrics) => {
            // Save ranking to db
            let ranking = Ranking::new(
                metrics,
                &user.username,
                RankOrdering::GreedyWeightedSetCover,
            );
            match add_ranking(ranking, db).await {
                Ok(ranking_id) => {
                    println!("New ranking generated by {}: {}", user.username, ranking_id);
                    status::Custom(Status::Ok, ranking_id)
                }
                Err(err) => {
                    println!("Something went wrong adding the ranking to the database: {err:?}");
                    status::Custom(
                        Status::InternalServerError,
                        Status::InternalServerError.reason_lossy().into(),
                    )
                }
            }
        }
        Err(err) => {
            println!("Something went wrong creating the ranking: {err:?}");
            status::Custom(
                Status::InternalServerError,
                Status::InternalServerError.reason_lossy().into(),
            )
        }
    }
}

generate_endpoint_roles!(GetRakingsRole, { Role::GetRankings });
#[get("/")]
pub(crate) async fn get_rankings(
    user: User,
    _required_roles: GetRakingsRole,
    db: &State<Surreal<Client>>,
) -> status::Custom<String> {
    let rankings_res = surrealdb::get_rankings(db).await;
    println!("{} is requesting the rankings", user.username);
    match rankings_res {
        Ok(rankings) => status::Custom(
            Status::Ok,
            serde_json::to_string(&rankings).expect("can serialize the rankings to JSON"),
        ),
        Err(err) => {
            println!("Something went wrong getting the rankings: {}", err);
            status::Custom(
                Status::InternalServerError,
                "Internal Server Error".to_string(),
            )
        }
    }
}

#[get("/<ranking_id>")]
pub(crate) async fn get_ranking(
    user: User,
    ranking_id: String,
    _required_roles: GetRakingsRole,
    db: &State<Surreal<Client>>,
) -> status::Custom<String> {
    println!("{} is requesting the ranking {ranking_id}", user.username);
    let rankings_res = surrealdb::get_ranking(&ranking_id, db).await;
    match rankings_res {
        Ok(ranking) => status::Custom(
            Status::Ok,
            serde_json::to_string(&ranking).expect("can serialize the ranking to JSON"),
        ),
        Err(err) => {
            println!("Something went wrong getting the rankings: {}", err);
            status::Custom(
                Status::InternalServerError,
                "Internal Server Error".to_string(),
            )
        }
    }
}

async fn generate_ranking(
    min_coverage: u8,
    db: &State<Surreal<Client>>,
) -> Result<Vec<String>, Error> {
    // Get all the controls from the database
    let controls = surrealdb::get_controls(db).await?;
    // Get all the metrics from the database
    let metrics = surrealdb::get_metrics(db).await?;

    // Get the relation between controls and metrics
    let metrics_for_control = surrealdb::get_metric_control_association(db).await?;

    // Start greedy: take the metric with the most associated controls (divided by its effort), strike out the controls
    let best_metrics = minimize_cost(&controls, &metrics, &metrics_for_control, min_coverage);

    Ok(Vec::from_iter(best_metrics.into_iter()))
}

/// Finds the best metrics to minimize the cost. This is a variant of the Weighted Set
/// Cover problem.
///
/// We solve it with a greedy algorithm, computing the cost for each metric and always
/// choosing the smallest one. To compute the cost, we divide the effort of the metric
/// by the total increase in coverage it would bring. To compute the increase in
/// coverage, we sum the one on each control the metric covers, but only if the control
/// was not completely covered yet.
pub(crate) fn minimize_cost(
    controls: &[Control],
    metrics: &[Metric],
    coverage_map: &BTreeMap<String, Vec<(String, u8)>>,
    min_coverage: u8,
) -> Vec<String> {
    let mut selected_metrics: Vec<String> = vec![];
    let mut unused_metrics: HashSet<&str> = metrics.iter().map(|m| m.identifier.as_str()).collect();
    let empty_vec = Vec::new();

    let mut remaining_controls: HashSet<&str> =
        controls.iter().map(|c| c.identifier.as_str()).collect();

    let mut controls_coverage: HashMap<&str, u8> = controls
        .iter()
        .map(|c| (c.identifier.as_str(), 0))
        .collect();

    let metric_efforts = BTreeMap::from_iter(
        metrics
            .iter()
            .map(|metric| (metric.identifier.as_str(), metric.effort)),
    );

    // Iterate until all controls are covered, adding the best metric every time
    while !(remaining_controls.is_empty() || unused_metrics.is_empty()) {
        let mut min_cost = f64::MAX;
        let mut best_metric: Option<&str> = None;

        for metric_id in &unused_metrics {
            // Controls that would be covered by this metric
            let covered_controls = coverage_map.get(*metric_id).unwrap_or(&empty_vec);

            let effort = *metric_efforts.get(metric_id).unwrap() as f64;
            let coverage_increase = covered_controls.iter().fold(0, |prev, c| {
                let control_id = c.0.as_str();
                let coverage = c.1;
                if
                // remaining_controls.contains(control_id) &&
                controls_coverage.get(control_id).unwrap() < &min_coverage {
                    // Add the contribution of this metric for this control
                    prev + coverage
                } else {
                    prev
                }
            }) as f64;
            let cost = effort / coverage_increase;

            let covered_ids: HashSet<&str> = covered_controls
                .iter()
                .map(|(control_id, _)| control_id.as_str())
                .collect();
            let incomplete_covered = remaining_controls.intersection(&covered_ids).count();

            // If this metric has the minimum cost and helps covering some incomplete controls
            if incomplete_covered > 0 && cost < min_cost {
                min_cost = cost;
                best_metric = Some(metric_id);
            }
        }

        // Add the best metric to the selected set and remove the covered controls from consideration
        if let Some(metric_id) = best_metric {
            selected_metrics.push(metric_id.to_string());
            unused_metrics.remove(metric_id);

            let controls = &coverage_map.get(metric_id).unwrap_or(&empty_vec);
            controls.iter().for_each(|(control_id, coverage)| {
                let prev_value = controls_coverage.get(control_id.as_str()).unwrap();
                let new_value = prev_value + coverage;
                controls_coverage.insert(control_id, new_value);
            });
            remaining_controls = remaining_controls
                .difference(
                    &controls
                        .iter()
                        .filter(|(control_id, _)| {
                            controls_coverage.get(control_id.as_str()).unwrap() >= &min_coverage
                        })
                        .map(|(c, _)| c.as_str())
                        .collect(),
                )
                .cloned()
                .collect();
        } else {
            break;
        }
    }

    selected_metrics
}
